interface VulnerabilityPattern {
  name: string;
  description: string;
  type: "backdoor" | "privileged" | "tokenomics" | "phishing" | "approvals" | "2fa" | "mev" | "multisig";
  severity: "critical" | "high" | "medium" | "low";
  regex: RegExp;
  impact: string;
  recommendations: string;
  requiresDeepScan: boolean;
}

export const vulnerabilityPatterns: VulnerabilityPattern[] = [
  // BACKDOOR VULNERABILITIES
  {
    name: "Hidden Ownership Backdoor",
    description: "Contract contains a hidden owner with privileged capabilities, creating a high risk of unauthorized actions.",
    type: "backdoor",
    severity: "critical",
    regex: /address\s+private\s+_\w*[oO]wner\w*;|address\s+private\s+\w*[oO]wner\w*;/g,
    impact: "The hidden owner can perform privileged actions at any time, leading to:\n- Unauthorized control outside of contract governance\n- Potential for severe manipulation\n- Bypass of transparent governance mechanisms",
    recommendations: "Remove the hidden owner mechanism entirely. If ownership capabilities are required:\n- Use transparent ownership through OpenZeppelin's Ownable\n- Implement time-locks for privileged functions\n- Consider using community governance for important decisions",
    requiresDeepScan: false
  },
  {
    name: "Backdoor Minting Function",
    description: "Contract contains a backdoor function allowing unlimited token minting.",
    type: "backdoor",
    severity: "critical",
    regex: /function\s+\w*[mM]int\w*\([^)]*\)[^{]*{[^}]*_mint\([^;]*;/g,
    impact: "The ability to mint unlimited tokens can lead to:\n- Token supply inflation without community knowledge\n- Severe price manipulation\n- Complete destruction of token value",
    recommendations: "Remove arbitrary minting capabilities or add proper restrictions:\n- Set hard caps on total supply that cannot be exceeded\n- Use transparent governance for minting decisions\n- Add time-locks for minting functions to allow users to exit if needed",
    requiresDeepScan: false
  },
  {
    name: "Backdoor Self-Destruct Mechanism",
    description: "Contract contains a self-destruct functionality that could be used to rugpull.",
    type: "backdoor",
    severity: "critical",
    regex: /selfdestruct\s*\(\s*[^)]*\s*\)|suicide\s*\(\s*[^)]*\s*\)/g,
    impact: "Self-destruct can be used to:\n- Instantly terminate the contract\n- Send all remaining ETH to a specified address\n- Make token worthless instantly by destroying functionality",
    recommendations: "Remove all self-destruct functionality from the contract. If contract termination is needed:\n- Implement a phased shutdown with timelock\n- Ensure users can withdraw their assets\n- Use a transparent upgrade mechanism instead",
    requiresDeepScan: false
  },
  
  // PRIVILEGED FUNCTIONS
  {
    name: "User Blacklisting With No Time-Lock",
    description: "Owner can instantly blacklist any address without warning, freezing their token holdings with no challenge period.",
    type: "privileged",
    severity: "high",
    regex: /function\s+\w*[bB]lacklist\w*\([^)]*address[^)]*\)[^{]*{[^}]*\}/g,
    impact: "Blacklisting can be weaponized to:\n- Freeze assets of legitimate users\n- Block transactions arbitrarily\n- Prevent critics or competitors from using the token",
    recommendations: "If blacklisting is necessary for compliance:\n- Add a time-lock to blacklisting functions\n- Require multi-signature approval\n- Create a transparent appeal process\n- Consider community governance for blacklists",
    requiresDeepScan: false
  },
  {
    name: "Dynamic Transaction Limits",
    description: "Owner can modify maximum transaction amount at any time, potentially trapping user funds by setting extremely low limits.",
    type: "privileged",
    severity: "high",
    regex: /function\s+set\w*([lL]imit|[mM]ax)\w*\([^)]*\)[^{]*{[^}]*\}/g,
    impact: "Arbitrary transaction limits can be used to:\n- Prevent users from selling tokens\n- Enforce unequal trading rules\n- Effectively lock user funds while allowing select addresses to trade",
    recommendations: "Either remove dynamic limits or add appropriate safeguards:\n- Set minimum values that cannot be breached\n- Add time-locks to limit changes\n- Create graduated changes that happen slowly\n- Consider community governance for limit changes",
    requiresDeepScan: false
  },
  {
    name: "Pausable Transfers Without Timelock",
    description: "Contract allows owner to pause all transfers with no time limitation, potentially freezing user assets indefinitely.",
    type: "privileged",
    severity: "high",
    regex: /function\s+\w*[pP]ause\w*\([^)]*\)|function\s+\w*[eE]nable[tT]rading\w*\([^)]*\)/g,
    impact: "Pausable transfers can be abused to:\n- Prevent selling during price drops\n- Create artificial scarcity\n- Lock funds permanently if owner abandons contract",
    recommendations: "If pausing is required for emergencies:\n- Add a maximum pause duration\n- Implement automatic unpausing\n- Require multi-signature approval\n- Add transparent criteria for pausing",
    requiresDeepScan: false
  },
  
  // TOKENOMICS MANIPULATION
  {
    name: "Arbitrary Fee Adjustment",
    description: "Contract allows owner to change transaction fees to arbitrary values at any time.",
    type: "tokenomics",
    severity: "high",
    regex: /function\s+set\w*[fF]ee\w*\([^)]*\)[^{]*{[^}]*\}/g,
    impact: "Dynamic fees can be manipulated to:\n- Extract excessive value from users\n- Prevent selling by setting near-100% fees\n- Create unpredictable trading conditions",
    recommendations: "Either remove fee-changing capabilities or add constraints:\n- Set maximum fee caps (e.g., 5%)\n- Implement timelocks for fee changes\n- Use a gradual fee change mechanism\n- Add community governance for fee adjustments",
    requiresDeepScan: false
  },
  {
    name: "Dynamic Tax/Burn Mechanism",
    description: "Owner can change taxes or burn rates at any time, potentially causing severe tokenomics imbalance.",
    type: "tokenomics",
    severity: "medium",
    regex: /function\s+set\w*([tT]ax|[bB]urn)\w*\([^)]*\)[^{]*{[^}]*\}/g,
    impact: "Dynamic tax/burn rates can be used to:\n- Create artificial deflationary pressure\n- Extract undue value from transactions\n- Manipulate price through supply changes",
    recommendations: "Add proper restrictions to tax/burn mechanisms:\n- Set hard caps on maximum rates\n- Implement gradual changes with timelock\n- Create transparent rules for rate changes\n- Consider removing dynamic aspects entirely",
    requiresDeepScan: false
  },
  {
    name: "Centralized Liquidity Control",
    description: "Contract allows owner to remove liquidity without restrictions or timelocks.",
    type: "tokenomics",
    severity: "critical",
    regex: /function\s+\w*[lL]iquidity\w*\([^)]*\)[^{]*{[^}]*\}|function\s+\w*[wW]ithdraw\w*\([^)]*\)[^{]*{[^}]*\}/g,
    impact: "Centralized liquidity control can lead to:\n- Complete draining of trading pools\n- Immediate collapse of token price\n- Classic 'rugpull' scenario leaving investors with worthless tokens",
    recommendations: "Properly secure liquidity:\n- Lock liquidity with a third-party service\n- Add timelocks to liquidity withdrawals\n- Require multi-signature approval\n- Gradually vest liquidity access over long periods",
    requiresDeepScan: true
  },
  
  // PHISHING VULNERABILITIES
  {
    name: "Deceptive Transaction Authorization",
    description: "Contract uses misleading function signatures or events to trick users into authorizing harmful transactions.",
    type: "phishing",
    severity: "critical",
    regex: /function\s+(transfer|approve|send|execute).*_callData|function\s+\w*\([^)]*\)\s+external\s+payable/g,
    impact: "Deceptive authorization can lead to:\n- Users unknowingly authorizing fund transfers\n- Asset theft through misleading transaction interfaces\n- Loss of funds through social engineering at the contract level",
    recommendations: "Prevent deceptive authorization:\n- Use standard, recognizable function signatures\n- Implement clear, explicit transaction confirmation\n- Add transaction simulation previews\n- Require multi-factor authentication for high-value transactions",
    requiresDeepScan: true
  },
  {
    name: "Address Spoofing Vulnerability",
    description: "Contract allows or facilitates address spoofing, potentially misleading users about transaction recipients.",
    type: "phishing",
    severity: "high",
    regex: /address\s+\w*\s*=\s*address\(this\).*msg\.sender|address\s+\w*\s*=\s*msg\.sender.*address\(this\)/g,
    impact: "Address spoofing can be used to:\n- Trick users into sending funds to wrong recipients\n- Impersonate trusted contracts or protocols\n- Execute false authorization flows",
    recommendations: "Protect against address spoofing:\n- Implement address verification mechanisms\n- Add explicit confirmation of recipient addresses\n- Use ENS or similar human-readable address systems\n- Avoid address manipulation in contract code",
    requiresDeepScan: true
  },
  
  // APPROVALS VULNERABILITIES
  {
    name: "Unrestricted Token Approvals",
    description: "Contract implements or encourages unlimited token approvals, creating perpetual security risks.",
    type: "approvals",
    severity: "high",
    regex: /approve\(.*,[^,]*\)|function\s+approve.*uint256.*MAX|function\s+\w*[aA]pprove\w*\([^)]*\)/g,
    impact: "Unrestricted approvals can lead to:\n- Permanent access to user funds\n- Exposure to future contract vulnerabilities\n- Complete asset loss if contract is compromised",
    recommendations: "Implement safer approval mechanisms:\n- Use specific, limited approval amounts\n- Add approval expiration timestamps\n- Implement automatic approval revocation after use\n- Encourage per-transaction approvals",
    requiresDeepScan: false
  },
  {
    name: "Hidden Approval Flows",
    description: "Contract contains subtle or hidden approval mechanisms that may activate without clear user consent.",
    type: "approvals",
    severity: "critical",
    regex: /function\s+\w*\([^)]*\)[^{]*{[^}]*approve\([^;]*;/g,
    impact: "Hidden approvals can be exploited to:\n- Gain control of user assets without explicit consent\n- Bypass standard authentication flows\n- Create backdoor access to funds",
    recommendations: "Eliminate hidden approval mechanisms:\n- Make all approval flows explicit and clear\n- Separate approval from other operations\n- Implement clear approval events and logs\n- Require explicit user confirmation for all approvals",
    requiresDeepScan: true
  },
  
  // 2FA VULNERABILITIES
  {
    name: "Missing Two-Factor Authentication",
    description: "Contract lacks secondary verification for high-risk operations, relying solely on possession of private keys.",
    type: "2fa",
    severity: "medium",
    regex: /transfer\([^)]+\).*value|send\([^)]+\).*value|call\{value:/g,
    impact: "Lack of 2FA can result in:\n- Single point of failure security model\n- Immediate loss if private key is compromised\n- No recovery path for compromised accounts",
    recommendations: "Implement multi-factor security:\n- Add time-locked operations for high-value transactions\n- Implement guardian or multi-signature requirements\n- Consider social recovery mechanisms\n- Allow users to set transaction limits requiring additional verification",
    requiresDeepScan: false
  },
  {
    name: "Vulnerable Recovery Mechanism",
    description: "Contract implements a vulnerable or exploitable account recovery process that circumvents security measures.",
    type: "2fa",
    severity: "high",
    regex: /function\s+\w*[rR]ecovery\w*\([^)]*\)|function\s+\w*[rR]eset\w*\([^)]*\)/g,
    impact: "Vulnerable recovery can lead to:\n- Account takeovers through social engineering\n- Bypass of intended security controls\n- False recovery claims and asset theft",
    recommendations: "Strengthen recovery processes:\n- Implement time-delayed recovery\n- Require multiple independent verifications\n- Use trusted external validators\n- Consider immutable social recovery contracts",
    requiresDeepScan: true
  },
  
  // MEV VULNERABILITIES
  {
    name: "Front-Running Vulnerability",
    description: "Contract operations are susceptible to front-running, allowing value extraction by miners or observers.",
    type: "mev",
    severity: "medium",
    regex: /function\s+swap\w*\([^)]*\)|exchange\w*\([^)]*\)|convert\w*\([^)]*\)/g,
    impact: "Front-running vulnerabilities enable:\n- Transaction reordering exploitation\n- Sandwich attacks on price movements\n- Unfair value extraction from users",
    recommendations: "Protect against front-running:\n- Implement commit-reveal schemes\n- Add minimum/maximum bounds to trades\n- Use batch auctions or other MEV-resistant designs\n- Consider private transaction pools or flashbots",
    requiresDeepScan: false
  },
  {
    name: "Time-Dependent Execution Risk",
    description: "Contract logic depends on precise execution timing, creating opportunities for manipulation and MEV extraction.",
    type: "mev",
    severity: "high",
    regex: /block\.timestamp|now|block\.number/g,
    impact: "Time-dependent vulnerabilities allow:\n- Targeted transaction ordering manipulation\n- Oracle price manipulation\n- Timestamp dependence exploitation",
    recommendations: "Minimize time-dependence risks:\n- Avoid direct use of block.timestamp for critical logic\n- Implement time buffer zones\n- Use oracles with Uniswap TWAP or similar time-weighted designs\n- Add slippage protection mechanisms",
    requiresDeepScan: true
  },
  
  // MULTISIG VULNERABILITIES
  {
    name: "Transaction Frontrunning Vulnerability",
    description: "Multisig wallet implementation is vulnerable to transaction frontrunning due to predictable transaction identifiers.",
    type: "multisig",
    severity: "high",
    regex: /bytes32\s+\w*\s*=\s*keccak256\s*\(\s*abi\.encodePacked\s*\([^)]*block\.timestamp[^)]*\)\s*\)/g,
    impact: "Transaction frontrunning in multisig wallets can lead to:\n- Malicious transaction ordering\n- Transaction replay attacks\n- Manipulation of execution sequence\n- Potential fund theft through predictable transaction IDs",
    recommendations: "Prevent transaction frontrunning in multisig wallets:\n- Implement commit-reveal pattern with user-provided salts\n- Add unique nonces to transaction IDs\n- Use signature schemes that prevent replay attacks\n- Avoid using block.timestamp in transaction ID generation",
    requiresDeepScan: true
  },
  {
    name: "Missing Multisig Timelock",
    description: "Multisig wallet lacks timelock protection for critical operations, allowing immediate execution after confirmation threshold is met.",
    type: "multisig",
    severity: "high",
    regex: /function\s+\w*execute\w*\([^)]*\)[^{]*{[^}]*\.\w*\([^)]*\)[^}]*\}/g,
    impact: "Lack of timelocks in multisig operations can result in:\n- No opportunity to cancel malicious transactions\n- Reduced security through immediate execution\n- Inability to respond to compromised signers\n- No recovery window for unauthorized confirmations",
    recommendations: "Implement proper timelock mechanisms in multisig wallets:\n- Add mandatory waiting periods between confirmation and execution\n- Enable transaction cancellation during waiting period\n- Create tiered timelock periods based on transaction value\n- Implement additional verification for high-value transactions",
    requiresDeepScan: false
  },
  {
    name: "Insecure Owner Management",
    description: "Multisig wallet implementation allows insecure management of wallet owners, potentially enabling malicious takeover.",
    type: "multisig",
    severity: "critical",
    regex: /function\s+\w*(add|remove|replace)Owner\w*\([^)]*\)[^{]*{[^}]*\}/g,
    impact: "Insecure owner management in multisig wallets can enable:\n- Malicious addition of controlled owners\n- Removal of legitimate owners\n- Complete takeover of the multisig wallet\n- Compromise of all secured assets",
    recommendations: "Secure owner management in multisig wallets:\n- Require a higher threshold for owner management operations\n- Implement extended timelock for owner changes\n- Add special verification for owner management\n- Ensure sufficient owners remain after any removal",
    requiresDeepScan: true
  }
];
