// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title VulnerabilityAnalysisPayment
 * @dev Smart contract for handling premium vulnerability analysis payments
 */
contract VulnerabilityAnalysisPayment {
    address public owner;
    uint256 public analysisCount;
    uint256 public standardPrice = 0.01 ether;
    uint256 public deepScanPrice = 0.025 ether;
    
    struct Analysis {
        address requester;
        string contractHash;
        bool deepScan;
        uint256 timestamp;
        uint256 amount;
    }
    
    mapping(uint256 => Analysis) public analyses;
    mapping(address => uint256[]) public userAnalyses;
    
    event AnalysisRequested(
        uint256 indexed analysisId, 
        address indexed requester, 
        string contractHash, 
        bool deepScan,
        uint256 amount
    );
    
    event PriceUpdated(uint256 newStandardPrice, uint256 newDeepScanPrice);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }
    
    constructor() {
        owner = msg.sender;
    }
    
    /**
     * @dev Request a standard vulnerability analysis (lower depth)
     * @param contractHash Hash of the contract to analyze
     */
    function requestStandardAnalysis(string memory contractHash) external payable {
        require(msg.value >= standardPrice, "Insufficient payment");
        
        uint256 analysisId = analysisCount;
        analyses[analysisId] = Analysis({
            requester: msg.sender,
            contractHash: contractHash,
            deepScan: false,
            timestamp: block.timestamp,
            amount: msg.value
        });
        
        userAnalyses[msg.sender].push(analysisId);
        analysisCount++;
        
        emit AnalysisRequested(analysisId, msg.sender, contractHash, false, msg.value);
    }
    
    /**
     * @dev Request a deep vulnerability analysis (higher depth)
     * @param contractHash Hash of the contract to analyze
     */
    function requestDeepAnalysis(string memory contractHash) external payable {
        require(msg.value >= deepScanPrice, "Insufficient payment");
        
        uint256 analysisId = analysisCount;
        analyses[analysisId] = Analysis({
            requester: msg.sender,
            contractHash: contractHash,
            deepScan: true,
            timestamp: block.timestamp,
            amount: msg.value
        });
        
        userAnalyses[msg.sender].push(analysisId);
        analysisCount++;
        
        emit AnalysisRequested(analysisId, msg.sender, contractHash, true, msg.value);
    }
    
    /**
     * @dev Update the prices for analysis services
     * @param newStandardPrice New price for standard analysis
     * @param newDeepScanPrice New price for deep scan analysis
     */
    function updatePrices(uint256 newStandardPrice, uint256 newDeepScanPrice) external onlyOwner {
        standardPrice = newStandardPrice;
        deepScanPrice = newDeepScanPrice;
        
        emit PriceUpdated(newStandardPrice, newDeepScanPrice);
    }
    
    /**
     * @dev Withdraw funds to the owner's address
     */
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        (bool success, ) = owner.call{value: balance}("");
        require(success, "Withdrawal failed");
    }
    
    /**
     * @dev Get all analysis IDs requested by a user
     * @param user Address of the user
     * @return Array of analysis IDs requested by the user
     */
    function getUserAnalyses(address user) external view returns (uint256[] memory) {
        return userAnalyses[user];
    }
    
    /**
     * @dev Get details of a specific analysis
     * @param analysisId ID of the analysis
     * @return Analysis struct containing the analysis details
     */
    function getAnalysisDetails(uint256 analysisId) 
        external 
        view 
        returns (
            address requester,
            string memory contractHash,
            bool deepScan,
            uint256 timestamp,
            uint256 amount
        ) 
    {
        Analysis memory analysis = analyses[analysisId];
        return (
            analysis.requester,
            analysis.contractHash,
            analysis.deepScan,
            analysis.timestamp,
            analysis.amount
        );
    }
    
    /**
     * @dev Get the current prices for analysis services
     * @return Current standard price and deep scan price
     */
    function getPrices() external view returns (uint256, uint256) {
        return (standardPrice, deepScanPrice);
    }
}
