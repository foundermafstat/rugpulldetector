// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title VulnerabilityAnalysisPayment
 * @dev Contract for handling payments for vulnerability analysis services
 */
contract VulnerabilityAnalysisPayment {
    address public owner;
    uint256 public standardAnalysisPrice = 0.01 ether;
    uint256 public deepScanAnalysisPrice = 0.05 ether;
    
    // Mapping from contract hash to payment status
    mapping(bytes32 => bool) public contractPaid;
    
    // Structure to store transaction details
    struct Transaction {
        address user;
        uint256 amount;
        bytes32 contractHash;
        bool deepScan;
        uint256 timestamp;
    }
    
    // Array to store all transactions
    Transaction[] public transactions;
    
    // Events
    event PaymentReceived(address indexed user, uint256 amount, bytes32 contractHash, bool deepScan);
    event PriceUpdated(uint256 standardPrice, uint256 deepScanPrice);
    event WithdrawalMade(address indexed to, uint256 amount);
    
    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    /**
     * @dev Pay for standard contract analysis
     * @param contractHash The hash of the contract code to analyze
     */
    function payForStandardAnalysis(bytes32 contractHash) external payable {
        require(msg.value >= standardAnalysisPrice, "Insufficient payment for standard analysis");
        require(!contractPaid[contractHash], "This contract has already been paid for");
        
        contractPaid[contractHash] = true;
        
        // Record the transaction
        transactions.push(Transaction({
            user: msg.sender,
            amount: msg.value,
            contractHash: contractHash,
            deepScan: false,
            timestamp: block.timestamp
        }));
        
        emit PaymentReceived(msg.sender, msg.value, contractHash, false);
    }
    
    /**
     * @dev Pay for deep scan contract analysis
     * @param contractHash The hash of the contract code to analyze
     */
    function payForDeepScanAnalysis(bytes32 contractHash) external payable {
        require(msg.value >= deepScanAnalysisPrice, "Insufficient payment for deep scan analysis");
        require(!contractPaid[contractHash], "This contract has already been paid for");
        
        contractPaid[contractHash] = true;
        
        // Record the transaction
        transactions.push(Transaction({
            user: msg.sender,
            amount: msg.value,
            contractHash: contractHash,
            deepScan: true,
            timestamp: block.timestamp
        }));
        
        emit PaymentReceived(msg.sender, msg.value, contractHash, true);
    }
    
    /**
     * @dev Check if a contract has been paid for
     * @param contractHash The hash of the contract code
     * @return bool Whether the contract has been paid for
     */
    function isContractPaid(bytes32 contractHash) external view returns (bool) {
        return contractPaid[contractHash];
    }
    
    /**
     * @dev Get the number of transactions
     * @return uint256 The number of transactions
     */
    function getTransactionCount() external view returns (uint256) {
        return transactions.length;
    }
    
    /**
     * @dev Get transaction details by index
     * @param index The index of the transaction
     * @return Transaction The transaction details
     */
    function getTransaction(uint256 index) external view returns (
        address user,
        uint256 amount,
        bytes32 contractHash,
        bool deepScan,
        uint256 timestamp
    ) {
        require(index < transactions.length, "Index out of bounds");
        Transaction memory txn = transactions[index];
        return (
            txn.user,
            txn.amount,
            txn.contractHash,
            txn.deepScan,
            txn.timestamp
        );
    }
    
    /**
     * @dev Update the prices for analysis services
     * @param newStandardPrice The new price for standard analysis
     * @param newDeepScanPrice The new price for deep scan analysis
     */
    function updatePrices(uint256 newStandardPrice, uint256 newDeepScanPrice) external onlyOwner {
        standardAnalysisPrice = newStandardPrice;
        deepScanAnalysisPrice = newDeepScanPrice;
        emit PriceUpdated(newStandardPrice, newDeepScanPrice);
    }
    
    /**
     * @dev Withdraw funds from the contract
     * @param to The address to send the funds to
     * @param amount The amount to withdraw
     */
    function withdraw(address payable to, uint256 amount) external onlyOwner {
        require(address(this).balance >= amount, "Insufficient contract balance");
        to.transfer(amount);
        emit WithdrawalMade(to, amount);
    }
    
    /**
     * @dev Get the contract balance
     * @return uint256 The contract balance
     */
    function getContractBalance() external view onlyOwner returns (uint256) {
        return address(this).balance;
    }
    
    /**
     * @dev Transfer contract ownership
     * @param newOwner The address of the new owner
     */
    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "New owner cannot be zero address");
        owner = newOwner;
    }
}
